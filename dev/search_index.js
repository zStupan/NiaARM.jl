var documenterSearchIndex = {"docs":
[{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api_reference/#Data-and-features","page":"API Reference","title":"Data and features","text":"","category":"section"},{"location":"api_reference/#Attributes-and-rules","page":"API Reference","title":"Attributes and rules","text":"","category":"section"},{"location":"api_reference/#Metrics","page":"API Reference","title":"Metrics","text":"","category":"section"},{"location":"api_reference/#Mining-pipeline","page":"API Reference","title":"Mining pipeline","text":"","category":"section"},{"location":"api_reference/#Optimization-setup","page":"API Reference","title":"Optimization setup","text":"","category":"section"},{"location":"api_reference/#Algorithms","page":"API Reference","title":"Algorithms","text":"","category":"section"},{"location":"api_reference/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api_reference/#NiaARM.Dataset","page":"API Reference","title":"NiaARM.Dataset","text":"Dataset(df_or_path)\n\nWrap a tabular dataset and derive feature metadata used by optimizers. Accepts either a DataFrame or path to a CSV file. Features are inferred from column types and overall problem dimensionality is computed for use with optimization algorithms.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#NiaARM.AbstractFeature","page":"API Reference","title":"NiaARM.AbstractFeature","text":"AbstractFeature\n\nAbstract supertype describing dataset columns used to build candidate rules.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#NiaARM.NumericalFeature","page":"API Reference","title":"NiaARM.NumericalFeature","text":"NumericalFeature(name, min, max)\n\nMetadata describing a numerical column along with its observed minimum and maximum. Bounds are used to scale optimizer solutions back into meaningful ranges.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#NiaARM.CategoricalFeature","page":"API Reference","title":"NiaARM.CategoricalFeature","text":"CategoricalFeature(name, categories)\n\nMetadata describing a categorical column and its possible category values.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#NiaARM.dtype","page":"API Reference","title":"NiaARM.dtype","text":"dtype(attribute)\n\nReturn the underlying numeric element type carried by an attribute or feature. For categorical elements, String is returned.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.isnumerical","page":"API Reference","title":"NiaARM.isnumerical","text":"isnumerical(feature)\n\nReturn true when a feature is numerical.\n\n\n\n\n\nisnumerical(attribute)\n\nReturn true when an attribute is numerical.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.iscategorical","page":"API Reference","title":"NiaARM.iscategorical","text":"iscategorical(feature)\n\nReturn true when a feature is categorical.\n\n\n\n\n\niscategorical(attribute)\n\nReturn true when an attribute is categorical.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.AbstractAttribute","page":"API Reference","title":"NiaARM.AbstractAttribute","text":"AbstractAttribute\n\nAbstract supertype for all attribute descriptors that can appear in a mined rule.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#NiaARM.NumericalAttribute","page":"API Reference","title":"NiaARM.NumericalAttribute","text":"NumericalAttribute(name, min, max)\n\nClosed interval constraint on a numerical feature used in rule antecedents or consequents. min must be less than or equal to max; the numeric element type is inferred from the provided bounds.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#NiaARM.CategoricalAttribute","page":"API Reference","title":"NiaARM.CategoricalAttribute","text":"CategoricalAttribute(name, category)\n\nEquality constraint on a categorical feature. Rules will match rows where the column name equals category.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#NiaARM.ContingencyTable","page":"API Reference","title":"NiaARM.ContingencyTable","text":"ContingencyTable(antecedent, consequent, transactions)\n\nSufficient statistics for evaluating a candidate rule against a dataset. Counts cover the four quadrants of a 2x2 contingency table and store amplitude/inclusion metadata computed during rule construction.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#NiaARM.Rule","page":"API Reference","title":"NiaARM.Rule","text":"Rule(antecedent, consequent[, fitness, ct])\n\nRepresents a mined association rule with its antecedent and consequent attribute constraints, the current fitness value, and a cached ContingencyTable.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#NiaARM.countall","page":"API Reference","title":"NiaARM.countall","text":"countall(ct::ContingencyTable)\ncountall(rule::Rule)\n\nNumber of transactions satisfying both antecedent and consequent.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.countlhs","page":"API Reference","title":"NiaARM.countlhs","text":"countlhs(ct::ContingencyTable)\ncountlhs(rule::Rule)\n\nNumber of transactions satisfying the antecedent only.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.countrhs","page":"API Reference","title":"NiaARM.countrhs","text":"countrhs(ct::ContingencyTable)\ncountrhs(rule::Rule)\n\nNumber of transactions satisfying the consequent only.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.countnull","page":"API Reference","title":"NiaARM.countnull","text":"countnull(ct::ContingencyTable)\ncountnull(rule::Rule)\n\nNumber of transactions satisfying neither antecedent nor consequent.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.support","page":"API Reference","title":"NiaARM.support","text":"support(ct::ContingencyTable)\nsupport(rule::Rule)\n\nFraction of transactions that satisfy both antecedent and consequent.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.confidence","page":"API Reference","title":"NiaARM.confidence","text":"confidence(ct::ContingencyTable)\nconfidence(rule::Rule)\n\nConditional probability of the consequent given the antecedent.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.coverage","page":"API Reference","title":"NiaARM.coverage","text":"coverage(ct::ContingencyTable)\ncoverage(rule::Rule)\n\nSupport of the antecedent.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.rhs_support","page":"API Reference","title":"NiaARM.rhs_support","text":"rhs_support(ct::ContingencyTable)\nrhs_support(rule::Rule)\n\nSupport of the consequent alone.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.lift","page":"API Reference","title":"NiaARM.lift","text":"lift(ct::ContingencyTable)\nlift(rule::Rule)\n\nRatio between joint support and the product of antecedent and consequent supports.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.conviction","page":"API Reference","title":"NiaARM.conviction","text":"conviction(ct::ContingencyTable)\nconviction(rule::Rule)\n\nMeasure of implication strength that penalizes counterexamples to the rule.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.interestingness","page":"API Reference","title":"NiaARM.interestingness","text":"interestingness(ct::ContingencyTable)\ninterestingness(rule::Rule)\n\nHeuristic metric combining confidence, normalized support, and consequent prior.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.yulesq","page":"API Reference","title":"NiaARM.yulesq","text":"yulesq(ct::ContingencyTable)\nyulesq(rule::Rule)\n\nYule's Q association measure derived from the contingency table odds ratio.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.netconf","page":"API Reference","title":"NiaARM.netconf","text":"netconf(ct::ContingencyTable)\nnetconf(rule::Rule)\n\nNet confidence metric capturing deviation from independence normalized by antecedent coverage.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.zhang","page":"API Reference","title":"NiaARM.zhang","text":"zhang(ct::ContingencyTable)\nzhang(rule::Rule)\n\nZhang's metric providing a bounded, symmetric interestingness score.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.leverage","page":"API Reference","title":"NiaARM.leverage","text":"leverage(ct::ContingencyTable)\nleverage(rule::Rule)\n\nAbsolute difference between observed and expected joint support under independence.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.amplitude","page":"API Reference","title":"NiaARM.amplitude","text":"amplitude(ct::ContingencyTable)\namplitude(rule::Rule)\n\nNormalized width of the numerical intervals selected in a rule.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.inclusion","page":"API Reference","title":"NiaARM.inclusion","text":"inclusion(ct::ContingencyTable)\ninclusion(rule::Rule)\n\nPortion of the dataset's feature space occupied by attributes present in the rule.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.comprehensibility","page":"API Reference","title":"NiaARM.comprehensibility","text":"comprehensibility(rule)\n\nLog-scaled measure preferring rules with smaller antecedents relative to consequents.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.mine","page":"API Reference","title":"NiaARM.mine","text":"mine(dataset, algorithm, criterion; metrics, kwargs...)\n\nRun numerical association rule mining on a dataset using the provided optimization algorithm and StoppingCriterion. Returns a list of discovered Rules sorted by fitness. metrics may be a Dict of weights or a list of metric names.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.narm","page":"API Reference","title":"NiaARM.narm","text":"narm(solution; problem, features, transactions, rules, metrics)\n\nObjective function used by optimization algorithms. Decodes solution into a rule, evaluates it on transactions with the provided metrics, and inserts novel rules into rules. Returns the negated fitness so minimizers can be used for maximization.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.Problem","page":"API Reference","title":"NiaARM.Problem","text":"Problem(dimension, lowerbound, upperbound[, lowerinit, upperinit])\n\nContinuous search-space description used by optimization algorithms. Bounds constrain candidate solutions and initialization ranges; validation guards against invalid domains.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#NiaARM.StoppingCriterion","page":"API Reference","title":"NiaARM.StoppingCriterion","text":"StoppingCriterion(; maxevals=typemax(Int), maxiters=typemax(Int), acceptable_fitness=-Inf)\n\nStop condition shared by all optimizers. At least one limit must be finite so that the search terminates.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#NiaARM.terminate","page":"API Reference","title":"NiaARM.terminate","text":"terminate(criterion, evals, iters, bestfitness)\n\nReturn true when any stopping condition is met.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.randomsearch","page":"API Reference","title":"NiaARM.randomsearch","text":"randomsearch(feval, problem, criterion; seed=nothing, kwargs...)\n\nBaseline optimizer that samples solutions uniformly within the problem bounds until the StoppingCriterion is met. Useful as a reference or for quick smoke tests.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.pso","page":"API Reference","title":"NiaARM.pso","text":"pso(feval, problem, criterion; popsize=10, omega=0.7, c1=2.0, c2=2.0, seed=nothing, kwargs...)\n\nParticle Swarm Optimization with inertia weight. Maintains a swarm of candidate rules, updating velocities toward personal and global best positions while respecting problem bounds.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.de","page":"API Reference","title":"NiaARM.de","text":"de(feval, problem, criterion; popsize=50, cr=0.8, f=0.9, seed=nothing, kwargs...)\n\nDifferential Evolution using DE/rand/1/bin strategy. Generates trial vectors via differential mutation and binomial crossover, selecting improvements greedily.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.ba","page":"API Reference","title":"NiaARM.ba","text":"ba(feval, problem, criterion; popsize=40, loudness0=1.0, pulse_rate0=1.0, fmin=0.0, fmax=2.0, alpha=0.97, gamma=0.1, seed=nothing, kwargs...)\n\nBat Algorithm implementation following frequency-tuned velocity updates and adaptive loudness/pulse rate schedules. Exploits the current global best while injecting random walks for local search.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.sa","page":"API Reference","title":"NiaARM.sa","text":"sa(feval, problem, criterion; initial_temp=100.0, min_temp=1e-12, cooling_rate=0.95, step_size=0.1, seed=nothing, kwargs...)\n\nSimulated Annealing with Gaussian perturbations. Accepts worse solutions according to the current temperature to escape local minima and cools multiplicatively.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.ga","page":"API Reference","title":"NiaARM.ga","text":"ga(feval, problem, criterion; popsize=50, tournament_size=5, crossover_rate=0.7, mutation_rate=0.05, seed=nothing, kwargs...)\n\nSteady-state Genetic Algorithm with tournament selection, uniform crossover, and per-gene mutation. Populations are clamped to the Problem bounds each generation.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.lshade","page":"API Reference","title":"NiaARM.lshade","text":"lshade(feval, problem, criterion; popsize=18, memorysize=6, pbestrate=0.11, archiverate=2.6, seed=nothing, kwargs...)\n\nL-SHADE with current-to-pbest/1/bin mutation, success-history based parameter adaptation, an external archive, and linear population size reduction. Requires StoppingCriterion.maxevals to be set for the reduction schedule.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.es","page":"API Reference","title":"NiaARM.es","text":"es(feval, problem, criterion; mu=15, lambda=100, sigmainit=0.3, tau=nothing, tauprime=nothing, seed=nothing, kwargs...)\n\nSelf-adaptive (μ, λ) Evolution Strategy with log-normal step-size control. Generates offspring via Gaussian perturbations and selects the best mu individuals each generation.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.abc","page":"API Reference","title":"NiaARM.abc","text":"abc(feval, problem, criterion; popsize=20, limit=100, seed=nothing, kwargs...)\n\nArtificial Bee Colony optimizer splitting workers and onlookers across a set of food sources. Exploits neighbor differences to propose new points and periodically replaces stagnant sources with scouts.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.cs","page":"API Reference","title":"NiaARM.cs","text":"cs(feval, problem, criterion; popsize=25, pa=0.25, seed=nothing, kwargs...)\n\nCuckoo Search using Lévy flights and discovery probability pa for nest replacement. Maintains best nest while generating new solutions via random permutations and heavy- tailed steps.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.fa","page":"API Reference","title":"NiaARM.fa","text":"fa(feval, problem, criterion; popsize=20, alpha=1.0, beta0=1.0, gamma=0.01, theta=0.97, seed=nothing, kwargs...)\n\nFirefly Algorithm where attraction decreases exponentially with distance. Random walk amplitude decays by theta each iteration to balance exploration and exploitation.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.fpa","page":"API Reference","title":"NiaARM.fpa","text":"fpa(feval, problem, criterion; popsize=25, p=0.8, seed=nothing, kwargs...)\n\nFlower Pollination Algorithm alternating global Lévy flights and local pollination steps with switch probability p. Tracks the current best solution across the population.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.randchoice","page":"API Reference","title":"NiaARM.randchoice","text":"randchoice(rng, n, k)\n\nPick k unique indices from 1:n using rng.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.randlevy","page":"API Reference","title":"NiaARM.randlevy","text":"randlevy(rng; alpha=0.01, beta=1.5)\n\nDraw a Lévy-distributed random variate using the Mantegna algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#NiaARM.initpopulation","page":"API Reference","title":"NiaARM.initpopulation","text":"initpopulation(popsize, problem, rng)\n\nSample an initial population uniformly within the problem initialization bounds.\n\n\n\n\n\n","category":"function"},{"location":"code_of_conduct/#Contributor-Covenant-Code-of-Conduct","page":"Contributor Covenant Code of Conduct","title":"Contributor Covenant Code of Conduct","text":"","category":"section"},{"location":"code_of_conduct/#Our-Pledge","page":"Contributor Covenant Code of Conduct","title":"Our Pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","category":"section"},{"location":"code_of_conduct/#Our-Standards","page":"Contributor Covenant Code of Conduct","title":"Our Standards","text":"Examples of behavior that contributes to creating a positive environment include:\n\nUsing welcoming and inclusive language\nBeing respectful of differing viewpoints and experiences\nGracefully accepting constructive criticism\nFocusing on what is best for the community\nShowing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\nThe use of sexualized language or imagery and unwelcome sexual attention or advances\nTrolling, insulting/derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or electronic address, without explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting","category":"section"},{"location":"code_of_conduct/#Our-Responsibilities","page":"Contributor Covenant Code of Conduct","title":"Our Responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","category":"section"},{"location":"code_of_conduct/#Scope","page":"Contributor Covenant Code of Conduct","title":"Scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","category":"section"},{"location":"code_of_conduct/#Enforcement","page":"Contributor Covenant Code of Conduct","title":"Enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","category":"section"},{"location":"code_of_conduct/#Attribution","page":"Contributor Covenant Code of Conduct","title":"Attribution","text":"This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org [version]: http://contributor-covenant.org/version/1/4/","category":"section"},{"location":"license/#License","page":"License","title":"License","text":"MIT License\n\nCopyright (c) 2022 Iztok Fister Jr.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide walks through installing NiaARM.jl, loading data, and mining your first association rules.","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"Activate the project and install dependencies:\n\njulia --project=. -e 'using Pkg; Pkg.instantiate()'\n\nOr add the package directly in the REPL:\n\njulia> using Pkg\njulia> Pkg.add(\"NiaARM\")","category":"section"},{"location":"getting_started/#Loading-data","page":"Getting Started","title":"Loading data","text":"NiaARM expects tidy tabular data. You can pass either a DataFrame or a path to a CSV file:\n\nusing NiaARM, CSV, DataFrames\n\ntransactions = CSV.read(\"datasets/sporty.csv\", DataFrame)\ndataset = Dataset(transactions)\n\nThe Dataset wrapper infers AbstractFeatures (numerical ranges or categorical values) and computes the problem dimensionality required by the optimizers.","category":"section"},{"location":"getting_started/#Mining-rules","page":"Getting Started","title":"Mining rules","text":"Choose an optimization algorithm (e.g. de, pso, ga, sa, randomsearch).\nConfigure a StoppingCriterion (limit evaluations, iterations, or acceptable fitness).\nPick metrics for fitness aggregation. Provide a vector of metric names (equal weights) or a Dict{Symbol,Float64} of weights.\n\nusing Random\n\ncriterion = StoppingCriterion(maxevals=5_000)\nmetrics = Dict(:support => 0.4, :confidence => 0.4, :lift => 0.2)\n\nrules = mine(dataset, de, criterion; metrics=metrics, seed=1234)\n\nfor rule in rules[1:5]  # top 5\n    println(rule, \" | fitness=\", rule.fitness, \" support=\", support(rule))\nend","category":"section"},{"location":"getting_started/#Picking-metrics","page":"Getting Started","title":"Picking metrics","text":"Available metrics include support, confidence, coverage, lift, conviction, interestingness, yulesq, netconf, zhang, leverage, amplitude, inclusion, and comprehensibility. See Interestingness Measures for definitions and guidance.","category":"section"},{"location":"getting_started/#Reusing-discovered-rules","page":"Getting Started","title":"Reusing discovered rules","text":"Rules are returned as Rule objects with cached contingency tables. You can compute any metric later without re-evaluating transactions:\n\nr = rules[1]\nprintln(confidence(r))\nprintln(rhs_support(r))","category":"section"},{"location":"getting_started/#Next-steps","page":"Getting Started","title":"Next steps","text":"Explore algorithm choices and parameter hints in Algorithms.\nVisualize mined rules with NarmViz.jl following Visualization.","category":"section"},{"location":"contributing/#Contributing-to-NiaARM.jl","page":"Contributing to NiaARM.jl","title":"Contributing to NiaARM.jl","text":":+1::tada: First off, thanks for taking the time to contribute! :tada::+1:","category":"section"},{"location":"contributing/#Code-of-Conduct","page":"Contributing to NiaARM.jl","title":"Code of Conduct","text":"This project and everyone participating in it is governed by the NiaARM.jl Code of Conduct. By participating, you are expected to uphold this code. Please report unacceptable behavior to iztok.fister1@um.si.","category":"section"},{"location":"contributing/#How-Can-I-Contribute?","page":"Contributing to NiaARM.jl","title":"How Can I Contribute?","text":"","category":"section"},{"location":"contributing/#Reporting-Bugs","page":"Contributing to NiaARM.jl","title":"Reporting Bugs","text":"Before creating bug reports, please check existing issues list as you might find out that you don't need to create one. When you are creating a bug report, please include as many details as possible in the issue template.","category":"section"},{"location":"contributing/#Suggesting-Enhancements","page":"Contributing to NiaARM.jl","title":"Suggesting Enhancements","text":"Open new issue using the feature request template.","category":"section"},{"location":"contributing/#Pull-requests","page":"Contributing to NiaARM.jl","title":"Pull requests","text":"Fill in the pull request template and make sure your code is documented.","category":"section"},{"location":"contributing/#Development-environment","page":"Contributing to NiaARM.jl","title":"Development environment","text":"All of the project's dependencies should be installed and the project ready for further development.","category":"section"},{"location":"contributing/#Dependencies","page":"Contributing to NiaARM.jl","title":"Dependencies","text":"Package Version Platform\nCSV 0.10.7 All\nCategoricalArrays 1.10.7 All\nDataFrames 1.4.4 All","category":"section"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"Visualization is handled by the companion package NarmViz.jl. It operates directly on the Rule objects returned by mine, so you can move seamlessly from mining to visual analysis.","category":"section"},{"location":"visualization/#Setup","page":"Visualization","title":"Setup","text":"Install NarmViz alongside NiaARM:\n\njulia> using Pkg\njulia> Pkg.add(\"NarmViz\")","category":"section"},{"location":"visualization/#Typical-workflow","page":"Visualization","title":"Typical workflow","text":"Mine rules with NiaARM:\nrules = mine(\"datasets/sporty.csv\", de, StoppingCriterion(maxevals=2_000); metrics=[:support, :confidence])\nPass the rules and original transactions to NarmViz. Consult NarmViz's documentation for available plots.\nusing NarmViz, CSV, DataFrames\ndataset = Dataset(\"datasets/sporty.csv\")\n\nvisualize(\n rules[1],\n dataset,\n path=\"example.pdf\", # path (if not specified, the plot will be displayed in the GUI)\n allfeatures=false, # visualize all features, not only antecedents and consequence\n antecedent=true, # visualize antecedent\n consequent=true, # visualize consequent\n timeseries=true, # set false for non-time series datasets\n intervalcolumn=\"interval\", # Name of the column which denotes the interval (only for time series datasets)\n interval=3 # which interval to visualize\n)","category":"section"},{"location":"#NiaARM.jl","page":"Home","title":"NiaARM.jl","text":"NiaARM.jl is a Julia framework for mining numerical association rules based on nature-inspired algorithms for optimization. Inspired by the NiaARM Python package, this package brings the power of numerical association rule mining to the Julia ecosystem.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Load datasets from CSV files.\nPreprocess data for mining.\nSearch for numerical association rules.\nUse built-in implementations of several state-of-the-art nature-inspired optimization algorithms.\nGenerate statistics for discovered rules.","category":"section"},{"location":"interestingness_measures/#Interestingness-measures","page":"Interestingness measures","title":"Interestingness measures","text":"","category":"section"},{"location":"interestingness_measures/#Support","page":"Interestingness measures","title":"Support","text":"Support is defined on an itemset as the proportion of transactions that contain the attribute X.\n\nsupp(X) = fracn_XD\n\nwhere D is the number of records in the transactional database.\n\nFor an association rule, support is defined as the support of all the attributes in the rule.\n\nsupp(X implies Y) = fracn_XYD\n\nRange: 0 1\n\nReference: Michael Hahsler, A Probabilistic Comparison of Commonly Used Interest Measures for Association Rules, 2015, URL: https://mhahsler.github.io/arules/docs/measures","category":"section"},{"location":"interestingness_measures/#Confidence","page":"Interestingness measures","title":"Confidence","text":"Confidence of the rule, defined as the proportion of transactions that contain the consequent in the set of transactions that contain the antecedent. This proportion is an estimate of the probability of seeing the consequent, if the antecedent is present in the transaction.\n\nconf(X implies Y) = fracsupp(X implies Y)supp(X)\n\nRange: 0 1\n\nReference: Michael Hahsler, A Probabilistic Comparison of Commonly Used Interest Measures for Association Rules, 2015, URL: https://mhahsler.github.io/arules/docs/measures","category":"section"},{"location":"interestingness_measures/#Lift","page":"Interestingness measures","title":"Lift","text":"Lift measures how many times more often the antecedent and the consequent Y occur together than expected if they were statistically independent.\n\nlift(X implies Y) = fracconf(X implies Y)supp(Y)\n\nRange: 0 infty (1 means independence)\n\nReference: Michael Hahsler, A Probabilistic Comparison of Commonly Used Interest Measures for Association Rules, 2015, URL: https://mhahsler.github.io/arules/docs/measures","category":"section"},{"location":"interestingness_measures/#Coverage","page":"Interestingness measures","title":"Coverage","text":"Coverage, also known as antecedent support, is an estimate of the probability that the rule applies to a randomly selected transaction. It is the proportion of transactions that contain the antecedent.\n\ncover(X implies Y) = supp(X)\n\nRange: 0 1\n\nReference: Michael Hahsler, A Probabilistic Comparison of Commonly Used Interest Measures for Association Rules, 2015, URL: https://mhahsler.github.io/arules/docs/measures","category":"section"},{"location":"interestingness_measures/#RHS-Support","page":"Interestingness measures","title":"RHS Support","text":"Support of the consequent.\n\nRHSsupp(X implies Y) = supp(Y)\n\nRange: 0 1\n\nReference: Michael Hahsler, A Probabilistic Comparison of Commonly Used Interest Measures for Association Rules, 2015, URL: https://mhahsler.github.io/arules/docs/measures","category":"section"},{"location":"interestingness_measures/#Conviction","page":"Interestingness measures","title":"Conviction","text":"Conviction can be interpreted as the ratio of the expected frequency that the antecedent occurs without the consequent.\n\nconv(X implies Y) = frac1 - supp(Y)1 - conf(X implies Y)\n\nRange: 0 infty (1 means independence, infty means the rule always holds)\n\nReference: Michael Hahsler, A Probabilistic Comparison of Commonly Used Interest Measures for Association Rules, 2015, URL: https://mhahsler.github.io/arules/docs/measures","category":"section"},{"location":"interestingness_measures/#Inclusion","page":"Interestingness measures","title":"Inclusion","text":"Inclusion is defined as the ratio between the number of attributes of the rule and all attributes in the database.\n\ninclusion(X implies Y) = fracX cup Ym\n\nwhere m is the total number of attributes in the transactional database.\n\nRange: 0 1\n\nReference: I. Fister Jr., V. Podgorelec, I. Fister. Improved Nature-Inspired Algorithms for Numeric Association Rule Mining. In: Vasant P., Zelinka I., Weber GW. (eds) Intelligent Computing and Optimization. ICO 2020. Advances in Intelligent Systems and Computing, vol 1324. Springer, Cham.","category":"section"},{"location":"interestingness_measures/#Amplitude","page":"Interestingness measures","title":"Amplitude","text":"Amplitude measures the quality of a rule, preferring attributes with smaller intervals.\n\nampl(X implies Y) = 1 - frac1nsum_k = 1^nfracUb_k - Lb_kmax(o_k) - min(o_k)\n\nwhere n is the total number of attributes in the rule, Ub_k and Lb_k are upper and lower bounds of the selected attribute, and max(o_k) and min(o_k) are the maximum and minimum feasible values of the attribute o_k in the transactional database.\n\nRange: 0 1\n\nReference: I. Fister Jr., I. Fister A brief overview of swarm intelligence-based algorithms for numerical association rule mining. arXiv preprint arXiv:2010.15524 (2020).","category":"section"},{"location":"interestingness_measures/#Interestingness","page":"Interestingness measures","title":"Interestingness","text":"Interestingness of the rule, defined as:\n\ninterest(X implies Y) = fracsupp(X implies Y)supp(X) cdot fracsupp(X implies Y)supp(Y)\ncdot (1 - fracsupp(X implies Y)D)\n\nHere, the first part gives us the probability of generating the rule based on the antecedent, the second part gives us the probability of generating the rule based on the consequent and the third part is the probability that the rule won't be generated. Thus, rules with very high support will be deemed uninteresting.\n\nRange: 0 1\n\nReference: I. Fister Jr., I. Fister A brief overview of swarm intelligence-based algorithms for numerical association rule mining. arXiv preprint arXiv:2010.15524 (2020).","category":"section"},{"location":"interestingness_measures/#Comprehensibility","page":"Interestingness measures","title":"Comprehensibility","text":"Comprehensibility of the rule. Rules with fewer attributes in the consequent are more comprehensible.\n\ncomp(X implies Y) = fraclog(1 + Y)log(1 + X cup Y)\n\nRange: 0 1\n\nReference: I. Fister Jr., I. Fister A brief overview of swarm intelligence-based algorithms for numerical association rule mining. arXiv preprint arXiv:2010.15524 (2020).","category":"section"},{"location":"interestingness_measures/#Netconf","page":"Interestingness measures","title":"Netconf","text":"The netconf metric evaluates the interestingness of association rules depending on the support of the rule and the support of the antecedent and consequent of the rule.\n\nnetconf(X implies Y) = fracsupp(X implies Y) - supp(X)supp(Y)supp(X)(1 - supp(X))\n\nRange: -1 1 (Negative values represent negative dependence, positive values represent positive dependence and 0 represents independence)\n\nReference: E. V. Altay and B. Alatas, \"Sensitivity Analysis of MODENAR Method for Mining of Numeric Association Rules,\" 2019 1st International Informatics and Software Engineering Conference (UBMYK), 2019, pp. 1-6, doi: 10.1109/UBMYK48245.2019.8965539.","category":"section"},{"location":"interestingness_measures/#Yule's-Q","page":"Interestingness measures","title":"Yule's Q","text":"The Yule's Q metric represents the correlation between two possibly related dichotomous events.\n\nyulesq(X implies Y) =\nfracsupp(X implies Y)supp(neg X implies neg Y) - supp(X implies neg Y)supp(neg X implies Y)\nsupp(X implies Y)supp(neg X implies neg Y) + supp(X implies neg Y)supp(neg X implies Y)\n\nRange: -1 1 (-1 reflects total negative association, 1 reflects perfect positive association and 0 reflects independence)\n\nReference: E. V. Altay and B. Alatas, \"Sensitivity Analysis of MODENAR Method for Mining of Numeric Association Rules,\" 2019 1st International Informatics and Software Engineering Conference (UBMYK), 2019, pp. 1-6, doi: 10.1109/UBMYK48245.2019.8965539.","category":"section"},{"location":"interestingness_measures/#Zhang's-Metric","page":"Interestingness measures","title":"Zhang's Metric","text":"Zheng's metric measures the strength of association (positive or negative) between the antecedent and consequent,  taking into account both their co-occurrence and non-co-occurrence.\n\nzhang(X implies Y) =\nfracconf(X implies Y) - conf(neg X implies Y)maxconf(X implies Y) conf(neg X implies Y)\n\nRange: -1 1 (-1 reflects total negative association, 1 reflects perfect positive association and 0 reflects independence)\n\nReference: T. Zhang, “Association Rules,” in Knowledge Discovery and Data Mining. Current Issues and New  Applications, 2000, pp. 245–256. doi: 10.1007/3-540-45571-X_31. ","category":"section"},{"location":"interestingness_measures/#Leverage","page":"Interestingness measures","title":"Leverage","text":"Leverage metric is difference between the frequency of antecedent and the consequent appearing together and the expected frequency of them appearing separately based on their individual support\n\nleverage(X implies Y) = support(X implies Y) - (support(X) times support(Y))\n\nRange: -1 1 (-1 reflects total negative association, 1 reflects perfect positive association and 0 reflects independence)\n\nReference: Gregory Piatetsky-Shapiro. 1991. Discovery, Analysis, and Presentation of Strong Rules. In Knowledge Discovery in Databases, Gregory Piatetsky-Shapiro and William J. Frawley (Eds.). AAAI/MIT Press, 229–248.","category":"section"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"NiaARM.jl implements several population-based metaheuristics. All optimizers share a common signature (feval, problem, stoppingcriterion; kwargs...) where feval is narm.","category":"section"},{"location":"algorithms/#Differential-Evolution-(DE)","page":"Algorithms","title":"Differential Evolution (DE)","text":"Entry point: de\nStrategy: DE/rand/1/bin with greedy selection.\nParameters: popsize, cr (crossover rate), f (differential weight).\nReference: Storn, R., & Price, K. (1997). Differential evolution–a simple and efficient heuristic for global optimization over continuous spaces. Journal of Global Optimization, 11(4), 341-359.","category":"section"},{"location":"algorithms/#Particle-Swarm-Optimization-(PSO)","page":"Algorithms","title":"Particle Swarm Optimization (PSO)","text":"Entry point: pso\nInertia-weight PSO with personal and global best attraction.\nParameters: popsize, omega, c1, c2.\nReference: Kennedy, J., & Eberhart, R. (1995). Particle swarm optimization. Proceedings of ICNN'95 - International Conference on Neural Networks, 4, 1942-1948.","category":"section"},{"location":"algorithms/#Genetic-Algorithm-(GA)","page":"Algorithms","title":"Genetic Algorithm (GA)","text":"Entry point: ga\nTournament selection, uniform crossover, and per-gene mutation.\nParameters: popsize, tournament_size, crossover_rate, mutation_rate.\nReference: Holland, J. H. (1992). Adaptation in Natural and Artificial Systems: An Introductory Analysis with Applications to Biology, Control, and Artificial Intelligence. MIT Press.","category":"section"},{"location":"algorithms/#Simulated-Annealing-(SA)","page":"Algorithms","title":"Simulated Annealing (SA)","text":"Entry point: sa\nGaussian perturbations with multiplicative cooling.\nParameters: initial_temp, cooling_rate, step_size.\nReference: Kirkpatrick, S., Gelatt, C. D., & Vecchi, M. P. (1983). Optimization by simulated annealing. Science, 220(4598), 671-680.","category":"section"},{"location":"algorithms/#Bat-Algorithm-(BA)","page":"Algorithms","title":"Bat Algorithm (BA)","text":"Entry point: ba\nFrequency-tuned velocity updates with adaptive loudness and pulse rate.\nParameters: popsize, fmin, fmax, loudness0, pulse_rate0, alpha, gamma.\nReference: Yang, X. S. (2010). A new metaheuristic bat-inspired algorithm. In Nature Inspired Cooperative Strategies for Optimization (NICSO 2010) (pp. 65-74). Springer.","category":"section"},{"location":"algorithms/#Artificial-Bee-Colony-(ABC)","page":"Algorithms","title":"Artificial Bee Colony (ABC)","text":"Entry point: abc\nWorker/onlooker/scout phases over food sources.\nParameters: popsize, limit.\nReference: Karaboga, D. (2005). An idea based on honey bee swarm for numerical optimization. Technical Report TR06, Erciyes University, Engineering Faculty, Computer Engineering Department.","category":"section"},{"location":"algorithms/#Cuckoo-Search-(CS)","page":"Algorithms","title":"Cuckoo Search (CS)","text":"Entry point: cs\nLévy flights with abandonment probability pa.\nParameters: popsize, pa.\nReference: Yang, X. S., & Deb, S. (2009). Cuckoo search via Lévy flights. 2009 World Congress on Nature & Biologically Inspired Computing (NaBIC), 210-214.","category":"section"},{"location":"algorithms/#Firefly-Algorithm-(FA)","page":"Algorithms","title":"Firefly Algorithm (FA)","text":"Entry point: fa\nAttraction decays exponentially with distance; random walks shrink via theta.\nParameters: popsize, alpha, beta0, gamma, theta.\nReference: Yang, X. S. (2008). Firefly algorithm. In Nature-Inspired Metaheuristic Algorithms (pp. 79-90). Luniver Press.","category":"section"},{"location":"algorithms/#Flower-Pollination-Algorithm-(FPA)","page":"Algorithms","title":"Flower Pollination Algorithm (FPA)","text":"Entry point: fpa\nSwitches between global Lévy flights and local pollination using probability p.\nParameters: popsize, p.\nReference: Yang, X. S. (2012). Flower pollination algorithm for global optimization. In Unconventional Computation and Natural Computation (pp. 240-249). Springer.","category":"section"},{"location":"algorithms/#L-SHADE","page":"Algorithms","title":"L-SHADE","text":"Entry point: lshade\nCurrent-to-pbest/1/bin DE with success-history adaptation and population reduction.\nParameters: popsize, memorysize, pbestrate, archiverate (requires StoppingCriterion.maxevals to be set).\nReference: Tanabe, R., & Fukunaga, A. (2014). Improving the search performance of SHADE using linear population size reduction. 2014 IEEE Congress on Evolutionary Computation (CEC), 1658-1665.","category":"section"},{"location":"algorithms/#Evolution-Strategy-(ES)","page":"Algorithms","title":"Evolution Strategy (ES)","text":"Entry point: es\nSelf-adaptive step sizes with log-normal mutations in a (μ, λ) setting.\nParameters: mu, lambda, sigmainit, tau, tauprime.\nReference: Schwefel, H. P. (1977). Numerische Optimierung von Computer-Modellen mittels der Evolutionsstrategie. Birkhäuser.","category":"section"},{"location":"algorithms/#Random-Search","page":"Algorithms","title":"Random Search","text":"Entry point: randomsearch\nGeneric stochastic search used as a simple baseline optimizer.","category":"section"}]
}
